use std::fs::File;
use std::io;
use std::io::{BufRead, BufReader};
use flate2::Compression;
use flate2::write::ZlibEncoder;
use sha1::{Digest, Sha1};
use crate::common::{get_object_path_by_hash, make_object_header, ObjectType};
use anyhow::{bail, Context};
use std::io::prelude::*;
use std::path::PathBuf;
use crate::object_read::read_and_decode_object_file;

pub struct NewObjectData<R: Read> {
    pub hash: String,
    pub header: String,
    pub data_reader: R,
}

pub fn create_blob_object(path: PathBuf, rewind: bool) -> anyhow::Result<NewObjectData<impl Read>> {
    let mut file = File::open(&path).context(format!("Failed to open file at {path:?}"))?;
    let meta = file.metadata().context(format!("Failed to extract metadata from {path:?}"))?;
    let header = make_object_header(ObjectType::Blob, meta.len());

    let hash = calc_object_hash(BufReader::new(&file), &header).context(format!("Failed to calc hash for {path:?}"))?;

    if rewind {
        file.rewind().context(format!("Failed to rewind file {path:?}"))?;
    }
    let res = NewObjectData {
        hash,
        header,
        data_reader: file,
    };
    Ok(res)
}

pub fn write_object_file(object_data: NewObjectData<impl Read>) -> anyhow::Result<String> {
    let NewObjectData{hash, header, mut data_reader} = object_data;

    let new_file_path_str = get_object_path_by_hash(&hash);
    let new_file_path = PathBuf::from(&new_file_path_str);
    if new_file_path.exists() {
        let existing_data = read_and_decode_object_file(new_file_path_str.clone())?;
        let existing_header = make_object_header(existing_data.object_type, existing_data.size);
        if existing_header == header {
            return Ok(hash);
        } else {
            bail!("Object {hash} already exists, and has a different header. Expected {header}, existing {existing_header}");
        }
    }
    let new_file = File::create(new_file_path).context(format!("Failed to create an object file {new_file_path_str}"))?;

    let mut encoder = ZlibEncoder::new(new_file, Compression::best());
    encoder.write(header.as_bytes()).context(format!("Failed to write compressed header data into {new_file_path_str}"))?;
    io::copy(&mut data_reader, &mut encoder).context(format!("Failed to write compressed data from reader to {new_file_path_str}"))?;
    encoder.finish().context(format!("Failed to flush compressed data from to {new_file_path_str}"))?;

    Ok(hash)
}

pub fn calc_object_hash(reader: impl BufRead, header: &str) -> anyhow::Result<String> {
    let mut hasher = Sha1::new();
    hasher.update(header.as_bytes());
    drain_reader_into_hasher(&mut hasher, reader)?;
    let hash = hex::encode(hasher.finalize());
    Ok(hash)
}

fn drain_reader_into_hasher(hasher: &mut impl Digest, mut reader: impl BufRead) -> anyhow::Result<()> {
    loop {
        let buf = reader.fill_buf()?;
        let read_len = buf.len();
        if read_len == 0 {
            break;
        }
        hasher.update(buf);
        reader.consume(read_len);
    }
    Ok(())
}

#[cfg(test)]
mod test {
    use super::*;
    
    const TEST_HASH: &'static str = "345b19aec241ec34d3e111a44ee2a14236f13856";
    const TEST_FILE_DATA: &'static str = "# Generated by Cargo
# will have compiled files and executables
debug/
target/

# These are backup files generated by rustfmt
**/*.rs.bk

# MSVC Windows builds of rustc generate these, which store debugging information
*.pdb

.idea/
";
    
    #[test]
    fn test_create_blob_object() -> anyhow::Result<()> {
        let data_len = TEST_FILE_DATA.as_bytes().len();
        let header = make_object_header(ObjectType::Blob, data_len as u64);
        assert_eq!(format!("blob {data_len}\0"), header);
        let reader = BufReader::new(TEST_FILE_DATA.as_bytes());
        let hash = calc_object_hash(reader, &header)?;
        assert_eq!(TEST_HASH, hash);
        Ok(())
    }
}
